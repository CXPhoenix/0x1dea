---
title: 為什麼你需要學研究方法？
description: 讓我們從「了解」走向「深究」的一條無止盡道路。
createdTime: 2026-03-01T18:33:16+08:00
thumbnail:
---

# 為什麼你需要學研究方法？

大多數人會在大學時期學到「研究方法」這門課程，尤其是理工科可以說是必學課程。

但課程完成後呢？或是畢業之後沒有在求學了呢？大概就不會用到這個東西了...

但在我看來這卻是非常重要、甚至可以說是你學習的路徑指引圖。這也是為什麼我要教高中生「研究方法」這件事。

<p style="text-align: center; font-size: 0.7em; color: #888">
（但高中其實有開「探究與實作」課程，就是教類似的事情...）
</p>

這邊我先不講「研究方法」要怎麼做，我想先來聊聊：為什麼學？怎麼學？可以參照什麼方法學？

這些我想會是最重要的事情！

::: tip 📋 學習目標

看完後，希望你將能夠：

1. 說明「做研究」的本質，以及它和日常解決問題的關係
2. 點出研究常見失敗原因，並對應到軟體工程中的「軟體危機」
3. 解釋軟體工程是什麼、它和「會寫程式」有什麼不同
4. 列舉軟體工程的主要開發方法論（瀑布、V 模型、螺旋、Agile、TDD）
5. 說明為何 SDLC、V 模型與 TDD 可以作為研究方法的思考框架
6. 理解資安研究的本質，以及為何「學資安」需要研究能力
7. 預覽整套課程的架構與學習路徑

:::

## 0.1 為什麼我們要做研究？

### 一個你一定有過的情況

你有沒有遇過這樣的事：

有一天，你的手機剛好沒電了。你好不容易找了兩條充電線，一條是你的，另一條是同學的。但你的線怎麼插都沒反應，同學的線一插就開始充電。

這時，你心裡出現了一個問題：「**為什麼我的線不能充電呢？**」

> 或是你沒出現這個問題，只覺得「線壞了，扔掉吧」也可以。
> 
> 但感覺你好有錢，還缺乾兒子嗎？ (^_−)−☆

然後你可能開始做一些事：

- 換一個插座試試看
- 換另一個充電頭
- 把線的接頭拔下來重新插
- 用同學的線接你的充電頭

你在做什麼？你在「控制變因，一次改變一件事，看看結果是否不同」。

<div style="text-align: center; padding: 1.5em 0;">

**你在做研究。**{style="font-size: 3em;"}

</div>

---

<span style="font-size: 2em; color: var(--vp-c-red-2)">研究</span>，本質上就是**對一個問題**，**<span style="text-decoration: underline; text-underline-offset: 0.2em;">系統性</span>地尋找答案**。

這個定義聽起來好像很廢話，但其中的「**<span style="font-size: 1.5em;">系統性</span>**」這兩個字是重要的關鍵。

以剛剛充電線的例子來說，你一次只換一個變因去找尋答案，想知道到底哪個環節出了差錯，這其實就蘊含著「系統性」的關鍵特性。但很多人面對更複雜的問題時，會同時做很多改變，即使問題解決了，也不知道是哪一個改變起了作用。

這就是為什麼我們**需要研究方法**：讓你的「找答案的過程」變得**嚴謹**、**可靠**、可以讓別人**相信**你的結論。

### 用遊戲來看「研究方法」

不知道你有沒有玩過一個經典的猜數字遊戲：1A2B。

簡單來說就是出題者心中想一個 4 位、每一個位數都不相同的數字，然後我們透過猜測時，出題者告訴我們這是幾個相同位置（A）或是存在在數字中但不在相同位置（B），來進行猜測。

計算方法例如：
$$
\begin{aligned}
& \begin{array}{rcccc l}
& 4 & 0 & 5 & 9 & \leftarrow \text{題目} \\
-) & 1 & 0 & 9 & 6 & \leftarrow \text{你猜的數字} \\
\hline
& \text{\_} & \text{A} & \text{B} & \text{\_} & 
\end{array} \\
& \quad \quad \quad \quad \ \Downarrow \\
& \quad \quad \quad \ \text{1A 1B}
\end{aligned}
$$

> 遊戲進行時，通常會限制一定的次數進行猜測（不然就滿無聊的哈）
> 
> 但初學者也可以不用這樣玩死自己啦！

現在問題是：我們要怎麼樣可以用**最少的次數**猜到數字？

你可能提出有很多方法，但你怎麼證明這些方法**真的有效**？

研究，就是在處理這樣的問題。

> 對我沒打算告訴你怎麼做，自己想 (・Д・)ノ

### 研究在哪裡？

研究不只存在於學術界。它存在於每一個需要「做出有根據的決策」的地方：

- **科學家**研究新藥是否有效
- **工程師**研究哪種材料最適合橋樑
- **資安研究員**研究某個系統有沒有漏洞
- **政策制定者**研究哪種政策能有效減少犯罪
- **你**研究哪個科系適合你、哪個補習班值得花錢

:::info 📌 研究的本質

研究 = 用**系統化**的方法，對一個問題尋找**有根據**{style="color: var(--vp-c-red-2)"}的答案{style="text-align: center; margin: 1.5em 0;"}

「有根據」意味著：你的結論不只是你的猜測，而是有資料、有邏輯支持的推論。

:::

## 0.2 做研究很難嗎？

**短答案：做壞研究很容易，做好研究很難。**

但「很難」不等於「你不行」。只是需要學方法。

讓我們做一個對比：

### 不用方法的「研究」

「我感覺喝咖啡有助於念書，因為我上次在咖啡廳念書考得不錯。」

這個「結論」有什麼問題？

- 你只有一次經驗（樣本太少）
- 你沒有考慮咖啡廳的環境、你的睡眠狀況、那次的題目難度
- 「考得不錯」怎麼定義？比平均高 1 分算嗎？10 分算嗎？
- 你沒有對照組（沒有咖啡的你，那次念書成果如何？）

### 用方法的研究

「我找了 30 名高中生，隨機分配為喝咖啡組和喝安慰劑（假咖啡）組，控制環境、時間、和測試難度，讓他們在相同條件下完成 20 題閱讀測驗，比較兩組的分數差異，並以 t 檢定確認差異是否達到統計顯著水準。」

這兩個的差距，就是「有沒有學過研究方法」的差距。

:::tip 「研究很難」的真正含義
研究本身不難，難的是：
1. **克制直覺**——你以為你知道答案，但真相可能相反
2. **控制混淆因素**——影響結果的變因非常多，你必須系統性地排除
3. **誠實面對不支持你的結果**——這是大多數人最難做到的一件事

但這些都是可以學會的技能，不是天賦。
:::

---

## 0.3 為什麼都做不好研究？

這是這門課最核心的問題之一。我們先來看常見的失敗原因，你會驚訝地發現，它們和 50 年前工程師遇到的問題幾乎一模一樣。

### 研究的常見失敗模式

| 失敗模式 | 具體情境 | 根本原因 |
|---------|---------|---------|
| 🔥 **沒有定義清楚問題就開始做** | 「我想做關於環保的科展」→ 三個月後還在迷路 | 沒有「需求分析」 |
| 🔥 **不知道「什麼叫成功」** | 實驗做完了，不知道結果好不好 | 沒有事先定義成功標準 |
| 🔥 **沒有控制變因** | 同時改變溫度和濃度，無法得出結論 | 實驗設計不嚴謹 |
| 🔥 **做了很多，但沒有回答問題** | 洋洋灑灑 30 頁報告，但問題是「A 影響 B」，結論卻在討論 C | Verification ✅，Validation ❌ |
| 🔥 **先有結論，再找資料** | 想要證明「喝牛奶讓人長高」，只找支持這個說法的文章 | 確認偏誤（Confirmation Bias） |
| 🔥 **從不修改，死守原計畫** | 實驗失敗了也繼續，不考慮調整方法 | 缺乏迭代思維 |

### 這些問題，工程師 50 多年前就遇到過了

1968 年，一群全球頂尖的電腦科學家聚集在德國 Garmisch，開了一場緊急會議。

那年，電腦數量正在爆炸性成長，但軟體卻越來越失控——**專案預算超支、延誤交付、做出來的東西根本不能用**。這個狀況被他們稱為「**軟體危機（Software Crisis）**」。

這場會議後來被稱為「NATO 軟體工程大會」，它做了一件很重要的事：**確立了「軟體工程（Software Engineering）」這個領域的存在**，並宣告：開發軟體不能只靠天才程式設計師的靈感，必須有系統化的工程方法。

研究也是一樣。「研究危機」其實一直存在：
- 全球每年發表的學術論文，有相當大比例無法被其他研究者重現（Replication Crisis）
- 很多科展報告的研究設計，存在根本性的邏輯問題
- 許多「發現」其實是確認偏誤的產物

**軟體工程師用了 50 年，把軟體開發從「黑魔法」變成「可以被學習和管理的工程學科」。我們要借用他們的方法，把研究也做到一樣的程度。**

---

## 0.4 軟體工程是什麼？

### 一個常見的誤解

很多人聽到「軟體工程師」，腦海中浮現的是：一個人在黑色螢幕前瘋狂打字，螢幕上滿滿的綠色程式碼在流動。

這個印象，大概只有 5% 是對的。

### 軟體工程的真實樣貌

**軟體工程（Software Engineering）** 是一個研究「如何系統化、有紀律地開發高品質軟體」的工程學科。

它關心的問題包括：
- 如何確認使用者真正需要什麼？
- 如何設計一個大型系統，讓它可以維護、可以擴展？
- 如何保證軟體沒有嚴重的錯誤？
- 如何讓一個由 100 人組成的團隊有效率地合作？
- 如何在有限的時間和預算內，交付符合要求的軟體？

:::info 📖 IEEE 的定義
IEEE（電機電子工程師學會）對軟體工程的官方定義（IEEE Std 610.12-1990）：

「將系統化、有紀律、可量化的方法，應用於軟體的開發、運作和維護的過程；以及對這些方法的研究。」

注意關鍵字：**系統化、有紀律、可量化**——這三個詞，同樣是好的研究應該具備的特質。
:::

### 軟體工程的誕生故事：1968 年的危機

讓我們回到 1968 年那場德國大會。

當時的軟體世界非常混亂。程式設計師們大多是天才，但他們憑直覺寫程式，沒有文件、沒有計畫、沒有系統。這在小程式上沒問題，但當系統規模越來越大——需要幾百萬行程式碼——靠直覺就不夠了。

幾個典型的慘況：
- 一個系統耗費數年開發，完成後才發現根本不符合使用者需求
- 加一個新功能，結果壞掉三個舊功能
- 原本的設計師離職，新人看不懂舊程式碼，只好全部重寫

1968 年，NATO 召集了 50 位來自 11 個國家的頂尖電腦科學家——包括後來影響整個計算機科學的 Edsger Dijkstra、Peter Naur 等人——在德國 Garmisch 召開會議。

他們達成一個共識：**寫程式必須從「藝術」進化成「工程」。**

這就是「軟體工程」這個詞被正式確立的歷史時刻。

---

## 0.5 軟體工程和「寫程式」有什麼不同？

這個問題非常重要，也是很多初學者的盲點。

### 一個比喻：廚師 vs. 餐廳老闆

**一個廚師（程式設計師）** 會做菜。他知道各種食材、烹飪技法，可以做出美味的料理。

**一個餐廳老闆（軟體工程師）** 不只要會做菜。他還需要：
- 知道市場上客人要什麼（需求分析）
- 規劃廚房動線讓出餐效率最高（系統設計）
- 管理廚師團隊確保出菜品質穩定（品質管理）
- 制定食品安全標準確保沒有食安問題（測試與驗證）
- 在客人抱怨時系統性地找出問題（除錯與維護）

| 維度 | 寫程式（Programming） | 軟體工程（Software Engineering） |
|------|--------------------|-------------------------------|
| **規模** | 個人專案 | 大型系統（多人協作） |
| **重點** | 讓程式跑起來 | 讓系統可靠、可維護、可擴充 |
| **產出** | 程式碼 | 程式碼 + 文件 + 測試 + 流程 |
| **思維** | 解決眼前的問題 | 預防未來的問題 |
| **工具** | 程式語言、IDE | 開發流程、版本控制、自動化測試、Code Review |

### 為什麼這個區別對研究者很重要？

因為做研究也有類似的區分：

- **「做實驗」** 類似於「寫程式」——你有一個具體的技能，可以把實驗跑出來
- **「做研究」** 類似於「軟體工程」——你需要系統化地規劃整個研究流程，確保結果有意義、可重現、邏輯嚴謹

很多學生只會「做實驗」，卻不懂「做研究」。這門課，就是要彌補這個差距。

---

## 0.6 軟體工程有哪些方法？有哪些規範？

這個部分我們先建立一個宏觀的視野，後面的模組會深入每一個主題。

### 主要開發方法論

軟體工程發展了幾十年，產生了多種開發方法論。每一種方法論，都是對之前方法的一種改進或回應。

#### 1. 瀑布模型（Waterfall Model，1970）

由 Winston Royce 在 1970 年的論文中描述（雖然他本人認為它有問題）。

```
需求 → 設計 → 實作 → 測試 → 維護
```

特色：階段嚴格順序，每個階段完成才進入下一個。
問題：現實世界的需求會變化，到了後期才發現前期錯誤，代價極高。

#### 2. V 模型（V-Model，1979）

由 Barry Boehm 在 1979 年的論文中提出，以強調驗證（Verification）和確效（Validation）為核心。

```
需求分析 ────────────────────── 驗收測試
  ↓系統設計 ────────────── 系統測試↑
    ↓架構設計 ────── 整合測試↑
      ↓模組設計 ── 單元測試↑
            ↓
           實作
```

**V 模型的核心思想：** 開發的每一個「左邊」階段，都對應一個「右邊」的測試階段。
這就是 Verification（你做對了嗎？）和 Validation（你做的是對的事嗎？）的結構化體現。

:::tip V 模型與研究的關係
V 模型告訴我們：每一個設計決策，都必須有對應的「驗證方式」。

在研究中這意味著：每一個研究假設（左邊），都應該有對應的「驗證方法」（右邊）。你在設計研究的時候，就必須同時想好「怎麼知道這個假設是對還是錯」。
:::

#### 3. 螺旋模型（Spiral Model，1986）

由 Barry Boehm 在 1986 年提出，強調風險管理和迭代。

核心概念：把整個開發過程變成多個循環，每一個循環都包含：規劃 → 風險評估 → 工程實作 → 客戶評估。

螺旋模型是第一個明確強調「**先識別最大風險，再決定怎麼做**」的開發方法。

#### 4. 敏捷開發（Agile Development，2001）

2001 年，17 位軟體開發先驅在美國猶他州的雪鳥滑雪場聚會，共同簽署了《敏捷宣言（Agile Manifesto）》。

核心宣言（四個核心價值）：
> - **個體與互動** 勝過 流程與工具
> - **可運作的軟體** 勝過 詳盡的文件
> - **與客戶協作** 勝過 合約談判
> - **回應變化** 勝過 依循計畫

Agile 的精神：把整個開發周期縮短成 2 週的「Sprint（衝刺）」，快速交付可用的東西，從真實反饋中學習，不斷調整。

Scrum、Kanban 是 Agile 的主要實踐框架。

#### 5. TDD（Test-Driven Development，測試驅動開發，2002）

由 Kent Beck 在其 2002 年著作中系統化闡述。

核心循環：**Red（先寫失敗的測試） → Green（寫最少程式碼讓測試通過） → Refactor（優化）**

TDD 的革命性在於：**它把「定義成功標準」這件事，移到「開始動手」之前。**

這在模組二中會有深入說明。

### 主要規範與標準

軟體工程也有國際標準，規範「好的軟體開發應該是什麼樣子」：

| 標準 | 制定機構 | 主要內容 |
|------|---------|---------|
| **ISO/IEC 12207** | ISO + IEC | 軟體生命週期流程的國際標準 |
| **ISO/IEC 25010** | ISO + IEC | 軟體品質模型（功能性、可靠性、效率、安全性等） |
| **IEEE Std 610.12** | IEEE | 軟體工程術語標準定義 |
| **IEEE Std 829** | IEEE | 軟體測試文件標準 |
| **CMMI** | Carnegie Mellon SEI | 軟體開發成熟度模型評估 |

:::info 這些標準跟我有什麼關係？
你不需要背這些標準的內容，但你應該知道它們的存在。

它們代表的是：世界上最頂尖的工程師，花了幾十年時間，把「什麼叫做做好一件複雜的事」提煉成可以被遵循的規範。

研究方法領域也有類似的「標準」——APA 論文格式、科學報告結構（IMRaD）、統計顯著水準的慣例等——這些都是社群共同遵循的規範，讓每個研究者的工作可以被比較和評估。
:::

---

## 0.7 為什麼 SDLC、V 模型及 TDD 可以幫助做研究？

這是這個模組最核心的問題。

### 問題的根源是一樣的

讓我們把「軟體危機」和「研究失敗」的共同問題並排來看：

| 軟體危機的問題（1968） | 研究失敗的問題（至今） |
|--------------------|--------------------|
| 需求不清楚就開始寫程式 | 問題不清楚就開始做實驗 |
| 沒有設計文件，邊做邊改 | 沒有研究計畫，實驗做到哪算哪 |
| 不測試，直到最後才發現問題 | 不驗證假設，實驗完了不知道代表什麼 |
| 系統做出來了，但客戶根本不要 | 實驗做完了，但沒有回答研究問題 |
| 一個人的離開導致整個系統崩潰 | 沒有文件和紀錄，別人無法重現研究 |

**問題的結構是一模一樣的。** 所以解法的結構也可以是一樣的。

### 三個工具的對應關係

**SDLC（軟體開發生命週期）→ 研究流程框架**

SDLC 把複雜的開發過程分成幾個清晰的階段，每個階段有明確的任務和產出。

研究流程也可以用同樣的方式結構化：問題定義 → 文獻回顧+研究設計 → 執行實驗 → 分析驗證 → 討論反思。

**SDLC 提供的是：把「複雜的研究過程」拆解成可管理的步驟的框架。**

---

**V 模型 → Verification & Validation 思維**

V 模型的左邊（開發/計畫）對應研究的「設計階段」，右邊（測試/驗證）對應研究的「驗證階段」。

V 模型帶來了兩個關鍵問題：
- **Verification（驗證）：** 你有按照計畫做嗎？（實驗步驟有沒有照著研究設計走？）
- **Validation（確效）：** 你做的事情有回答你的問題嗎？（這個實驗真的能回答你的研究問題嗎？）

**V 模型提供的是：確保研究「做對了」且「做了對的事」的雙重檢核思維。**

---

**TDD → 假設驅動研究（Hypothesis-Driven Research）**

TDD 的 Red 階段（先寫測試）對應研究的「提出假設」：在開始做實驗之前，先定義清楚「什麼結果代表假設成立，什麼結果代表假設不成立」。

**TDD 提供的是：在動手之前先定義「成功標準」的思維習慣。**

### 三個工具的整合視圖

```
┌────────────────────────────────────────────────────────┐
│                   SDLC：研究的骨架                       │
│  問題定義 → 研究設計 → 實驗執行 → 分析驗證 → 討論反思     │
│                                                        │
│  ┌─────────────────────────────────────────────┐      │
│  │              V 模型：品質的保證                │      │
│  │  設計時就想好驗證方法（Verification + Validation）│     │
│  │                                             │      │
│  │  ┌──────────────────────────────────────┐   │      │
│  │  │        TDD：假設的紀律                 │   │      │
│  │  │  先定義成功標準，再開始做實驗           │   │      │
│  │  └──────────────────────────────────────┘   │      │
│  └─────────────────────────────────────────────┘      │
└────────────────────────────────────────────────────────┘
```

**SDLC 是外層結構，V 模型是品質保證機制，TDD 是核心思維習慣。三者共同構成了一套嚴謹的研究邏輯系統。**

---

## 0.8 為什麼打資安要學習做研究？

### 一個 23 歲學生改變了網路歷史的故事

1988 年 11 月 2 日，晚上 8:30。

一段程式碼從 MIT 的某台電腦被悄悄釋出，開始在網路上蔓延。它的作者，是一位 23 歲的 Cornell 大學資工所研究生，名叫 **Robert Tappan Morris**。

當時的網際網路非常小——全球只有約 60,000 台電腦連接其中，主要是大學和政府機構。沒有人想到這個網路有多脆弱。

24 小時之內，**6,000 台電腦癱瘓**——佔整個網際網路的 10%。哈佛、史丹佛、NASA 全都中招。

這隻程式，後來被稱為「**Morris Worm（莫里斯蠕蟲）**」，是有史以來第一個引起廣泛關注的網路蠕蟲病毒。

Morris 並不想造成破壞——他只是想量測網際網路的規模。但他的程式有一個小邏輯錯誤，導致蠕蟲不斷複製自己，最終拖垮了目標主機。

**這就是沒有做好 V&V 的後果：程式做出來了（Verification 大致 OK），但完全沒有達到原本的目標（Validation 失敗），還造成了重大損害。**

Morris 後來成為第一個被美國《電腦詐欺及濫用法》定罪的人，被判處三年緩刑、400 小時社區服務和 $10,050 罰金。

:::warning 道德啟示
Morris Worm 事件最重要的教訓不只是技術層面的，而是倫理層面的：
**在資安領域，「我沒有想要造成傷害」不是免責的理由。**

沒有充分測試和驗證的行動，即使出發點是好的，也可能造成嚴重後果。這和研究倫理完全一致：你的方法必須嚴謹，你的影響必須被充分考慮。
:::

### 資安研究的本質

資安研究員是什麼？

他們是**每天都在解答研究問題的人**：
- 這個系統有沒有漏洞？（研究問題）
- 如果有，怎麼被利用？（實驗設計）
- 能不能被防禦？（對立假設驗證）
- 防禦方案有效嗎？（V&V）

優秀的資安研究員，不只是技術強的「攻擊者」或「防禦者」——他們是嚴謹的研究者，只是研究的對象是系統的安全性。

### 為什麼沒有研究能力的資安人員會卡關？

**情境一：初學者的 CTF 困境**

CTF（Capture The Flag）是資安競賽，你需要找到隱藏在各種系統中的「旗幟（flag）」。

很多初學者玩 CTF 的方式是：上網查「這道題怎麼解」，找到 writeup 跟著做，然後... 下一道新題目又卡住了。

**為什麼？因為他們沒有研究能力。** 他們沒有辦法：
- 系統性地觀察一個未知的問題
- 形成假設並設計驗證方法
- 從失敗的嘗試中提取有用的資訊

**情境二：漏洞研究（Vulnerability Research）**

真正的漏洞研究，就是問：「這個系統的設計，是否存在可以被利用的邏輯漏洞？」

這個問題的回答方式，和科學研究幾乎完全相同：
1. 了解系統架構（文獻回顧）
2. 提出潛在漏洞假設（研究假設）
3. 設計測試案例驗證（TDD 思維）
4. 確認漏洞存在與利用方式（實驗執行）
5. 撰寫漏洞報告（研究報告）
6. 提出修補方案（討論與建議）

**沒有研究方法的基礎，漏洞研究只會是碰運氣。**

---

## 0.9 如何套用 SDLC、V 模型及 TDD 來學習研究資安？

### 資安研究的 SDLC 對應

讓我們把 SDLC 套用到一個具體的資安學習場景：「研究一個 Web 應用程式是否有 SQL Injection 漏洞」

| SDLC 階段 | 資安研究對應 | 具體行動 |
|-----------|------------|---------|
| **需求分析** | 定義研究目標 | 「我要測試這個登入頁面是否存在 SQL Injection 漏洞」 |
| **系統設計** | 威脅建模與測試計畫 | 了解 SQL Injection 的原理，設計測試向量（Test Vector） |
| **實作** | 實際測試 | 在合法的測試環境（如 DVWA）中嘗試各種注入語句 |
| **測試（V&V）** | 驗證漏洞 + 確認影響範圍 | 確認漏洞可重現（Verification）、評估影響範圍（Validation） |
| **維護** | 漏洞報告與修補建議 | 撰寫清楚的漏洞報告，提出修補方案 |

### 資安研究的 V 模型對應

V 模型在資安中對應的是「**滲透測試（Penetration Testing）**」的思維：

```
威脅建模 ─────────────────── 安全評估
  ↓安全需求 ────────── 功能測試↑
    ↓安全架構 ──── 滲透測試↑
      ↓元件設計 ─ 漏洞掃描↑
              ↓
          程式碼審查
```

左側是「設計階段」，右側是「驗證階段」。一個嚴謹的安全測試，必須對照原始的設計目標來驗證。

### 資安研究的 TDD 對應

在資安中，TDD 的思維對應到「**先定義攻擊場景，再測試防禦是否有效**」：

**Red 階段（定義攻擊假設）：**
「如果攻擊者輸入 `' OR '1'='1`，登入頁面應該要拒絕這個輸入（而不是讓他登入成功）」

**Green 階段（測試防禦）：**
在測試環境中輸入這個字串，觀察系統行為

**Refactor 階段（優化防禦）：**
如果系統被繞過，分析原因，改善防禦機制，再次測試

### 一個重要的提醒

:::warning ⚠️ 法律與道德邊界
所有的安全測試，**必須在你有明確授權的系統上進行**。

對你沒有授權的系統進行任何形式的滲透測試，在台灣是違法的，依《刑法》第 358 條（入侵電腦罪）可處 3 年以下有期徒刑。

合法的學習環境包括：
- **刻意設計有漏洞的練習系統**：如 DVWA（Damn Vulnerable Web App）、WebGoat
- **CTF 競賽平台**：picoCTF、AIS3 EOF、Pwnable.tw
- **自己架設的本地環境**：用虛擬機練習
- **有明確授權的 Bug Bounty 計畫**

道德的資安研究者，找到漏洞後會負責任地揭露（Responsible Disclosure），不會利用或販售，也不會在沒有授權的情況下測試。
:::

---

## 0.10 本課程的地圖

現在你已經了解了這門課的整體邏輯。讓我們看看接下來的旅程：

```
模組零（本模組）
先備知識與學習動機
「為什麼我要學這個？」
         ↓
模組一：SDLC 與研究流程
「做研究的骨架是什麼？」
         ↓
模組二：TDD 與假設驅動研究
「先定義成功，再開始做」
         ↓
模組三：Verification & Validation
「你做對了嗎？你做的是對的事嗎？」
         ↓
模組四：從資料到結論
「怎麼從數據得出嚴謹的結論？」
         ↓
模組五：小論文 / 科展報告撰寫
「怎麼把研究變成文字？」
         ↓
模組六：資安入門——當駭客也是在做研究
「CTF 初探、漏洞概念、紅藍隊思維」
```

每一個模組都不是孤立的，它們構成了一個完整的知識鏈。**SDLC 是骨架，TDD 是核心思維習慣，V&V 是品質保證，資料分析是推論工具，寫作是輸出，資安是應用場景。**

---

## 動手做 0-A：找出你生活中的「研究問題」

:::info 📝 練習說明
時間：約 15 分鐘
目的：發現研究問題無所不在，打破「研究=學術」的誤解
:::

**任務：** 在接下來 24 小時內，找出你生活中至少 3 個「讓你好奇的問題」，並嘗試回答以下問題：

| 生活中的好奇 | 這是研究問題嗎？ | 如何用研究方法回答它？ |
|------------|--------------|-------------------|
| 例：為什麼我打球的時候比較容易念書？ | 是的，這是「運動與學習效率」的問題 | 測量運動前後的記憶測驗分數，比較差異 |
| 你的問題 1：___ | | |
| 你的問題 2：___ | | |
| 你的問題 3：___ | | |

**分享：** 選一個你最感興趣的問題，想想看：用 SDLC 的「需求分析」來定義這個問題，你會怎麼寫？

---

## 動手做 0-B：軟體危機 vs. 你的研究危機

:::info 📝 練習說明
時間：約 20 分鐘
目的：把「軟體危機」的教訓對應到自己的研究習慣
:::

**任務：** 下面是 1968 年軟體危機中常見的問題。試著為每一個找出你在做科展或作業時「犯過的類似錯誤」：

| 軟體危機問題 | 你的研究/作業經驗中的類似情況 |
|------------|--------------------------|
| 需求不清楚就開始寫程式 | |
| 沒有文件，別人看不懂你的程式 | |
| 做出來的東西客戶根本不要 | |
| 加一個功能，壞掉三個功能 | |
| 測試留到最後，出問題才發現 | |

**反思問題：** 你認為這些問題，是「工程師個人的問題」，還是「開發流程沒有設計好的問題」？這個反思對你的研究有什麼啟示？

---

## 本模組重點整理

:::tip 📌 記住這六件事

1. **研究 = 系統性地對問題尋找有根據的答案**。「系統性」是關鍵詞，沒有方法的「研究」只是猜測。

2. **做不好研究的原因，和 1968 年「軟體危機」的原因幾乎一樣**：需求不清、沒有驗證、缺乏迭代思維。

3. **軟體工程 ≠ 寫程式**。它是「如何系統化開發高品質軟體」的工程學科，關心的是流程、品質和方法，而不只是程式碼。

4. **SDLC（骨架）+ V 模型（品質保證）+ TDD（假設紀律）= 嚴謹研究的三層結構**。這三個工具的結合，可以解決大多數研究失敗的根本問題。

5. **資安研究 = 用研究方法研究系統安全性**。沒有研究能力的資安人員，只能靠運氣和別人的 writeup 存活。

6. **所有資安練習必須在合法授權的環境中進行。** 這是技術門檻之前最重要的道德和法律邊界。
:::

---

## 課前自我評量

在進入模組一之前，試著回答以下問題（不需要寫出來，在腦海中想一想就好）：

- [ ] 你能說出「研究」和「查資料」的差別嗎？
- [ ] 你知道 1968 年的「軟體危機」指的是什麼嗎？
- [ ] 你能說出軟體工程和「會寫程式」的三個差別嗎？
- [ ] 你能用一句話解釋 SDLC、V 模型和 TDD 各自的核心思想嗎？
- [ ] 你知道為什麼在別人的系統上亂測試是違法的嗎？

如果這五個問題你都能回答，你已經準備好進入模組一了！

---

## 參考文獻

Beck, K., Beedle, M., van Bennekum, A., Cockburn, A., Cunningham, W., Fowler, M., Grenning, J., Highsmith, J., Hunt, A., Jeffries, R., Kern, J., Marick, B., Martin, R. C., Mellor, S., Schwaber, K., Sutherland, J., & Thomas, D. (2001). *Manifesto for agile software development*. Agile Alliance. https://agilemanifesto.org/

Beck, K. (2002). *Test-driven development: By example*. Addison-Wesley. ISBN 978-0-321-14653-3

Boehm, B. W. (1979). *Guidelines for verifying and validating software requirements and design specifications*. European Computing Conference.

Boehm, B. W. (1988). A spiral model of software development and enhancement. *Computer*, *21*(5), 61–72. https://doi.org/10.1109/2.59

Federal Bureau of Investigation. (2018, November 2). *Morris worm 30 years since first major attack on internet*. FBI News. https://www.fbi.gov/news/stories/morris-worm-30-years-since-first-major-attack-on-internet-110218

IEEE. (1990). *IEEE standard glossary of software engineering terminology* (IEEE Std 610.12-1990). Institute of Electrical and Electronics Engineers. https://doi.org/10.1109/IEEESTD.1990.101064

ISO/IEC. (2017). *ISO/IEC 12207:2017 — Systems and software engineering — Software life cycle processes*. International Organization for Standardization.

Naur, P., & Randell, B. (Eds.). (1969). *Software engineering: Report of a conference sponsored by the NATO Science Committee, Garmisch, Germany, 7–11 October 1968*. Scientific Affairs Division, NATO. http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF

Pressman, R. S., & Maxim, B. R. (2014). *Software engineering: A practitioner's approach* (8th ed.). McGraw-Hill Education.

Royce, W. W. (1987). Managing the development of large software systems: Concepts and techniques. *Proceedings of the 9th International Conference on Software Engineering*, 328–338. (Original work published 1970)

Sommerville, I. (2016). *Software engineering* (10th ed.). Pearson Education. ISBN 978-0-13-394303-0

Standish Group International. (1994). *The CHAOS report*. Standish Group.

